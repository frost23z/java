{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#overview-of-java","title":"Overview of Java","text":"<p>Java is a widely-used, platform-independent programming language known for its simplicity and power. As an object-oriented language similar to C++ and C#, it offers clear structure and code reusability. Its open-source nature, robust security, and extensive community support have secured its position as a leading programming language in the industry.</p>"},{"location":"#jvm-jre-jdk","title":"JVM, JRE, JDK","text":"Note <p>Java bytecode is platform independent, but JVM and JRE are platform dependent, requiring specific implementations for each operating system.</p> Component Description Contains JVM Executes Java bytecode - Java interpreter- JIT compiler- Garbage collector JRE Runs Java applications - JVM- Core classes- Supporting files JDK Complete development package - JRE- Development tools- Documentation"},{"location":"#run-java-program","title":"Run Java Program","text":"Compile and Run <p>Compile the Java file using the <code>javac</code> command. Ensure the file name matches the public class name. Run the compiled program using the <code>java</code> command with the class name (without the <code>.java</code> extension).</p> <pre><code>javac HelloWorld.java\njava HelloWorld\n</code></pre> <p>Alternative (Java 11 and later)</p> <p>\ufe0fDirectly compile and run a Java file in one step using the <code>java</code> command:</p> <p><pre><code>java HelloWorld.java\n</code></pre> This eliminates the need for a separate compilation step, making it convenient for quick testing and scripting.</p> Main Method <p>The <code>main</code> method is the entry point of a Java program. It must be declared as <code>public</code>, <code>static</code>, and return <code>void</code>. The method signature is:</p> <p><pre><code>public static void main(String[] args) {\n    // Code goes here\n}\n</code></pre> - The <code>args</code> parameter is an array of strings that can be used to pass command-line arguments to the program. It is important to note that the length of this array can vary based on the number of arguments provided during execution. Additionally, if no arguments are provided, the length of the <code>args</code> array will be zero.</p>"},{"location":"annotations/","title":"Annotations","text":"Annotations <ul> <li>Annotations are a way to add metadata to your code.</li> <li>They provide additional information about the code, such as its purpose, author, or version.</li> <li>Common use cases include:<ul> <li>Marking code as deprecated.</li> <li>Providing hints to the compiler.</li> <li>Associating metadata with classes, methods, or variables.</li> </ul> </li> </ul> Key FeaturesCommon Built-in AnnotationsCustom AnnotationsProcessing Annotations <ul> <li>Retention Policies:<ul> <li><code>SOURCE</code>: Annotations are discarded during the compile-time.</li> <li><code>CLASS</code>: Annotations are present in the <code>.class</code> file but not available at runtime.</li> <li><code>RUNTIME</code>: Annotations are available at runtime via reflection.</li> </ul> </li> <li>Target Elements:<ul> <li><code>@Target</code> specifies where an annotation can be applied (e.g., <code>METHOD</code>, <code>FIELD</code>, <code>TYPE</code>).</li> </ul> </li> <li>Custom Annotations:<ul> <li>You can define your own annotations using <code>@interface</code>.</li> </ul> </li> </ul> <ul> <li> <p><code>@Override</code>: </p> <ul> <li>Indicates that a method overrides a method in a superclass.</li> <li>Benefit: Ensures that the method exists in the superclass. If the method signature is incorrect or the method does not exist, the compiler will throw an error, preventing runtime issues.</li> <li> <p>Example:</p> <pre><code>class Parent {\n    void display() {\n        System.out.println(\"Parent display\");\n    }\n}\n\nclass Child extends Parent {\n    @Override\n    void display() { // Ensures this method correctly overrides the parent method\n        System.out.println(\"Child display\");\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p><code>@Deprecated</code>: </p> <ul> <li>Marks a method or class as deprecated.</li> <li>Benefit: Alerts developers that the annotated element should no longer be used and may be removed in future versions.</li> <li> <p>Example:</p> <pre><code>class Example {\n    @Deprecated\n    public void oldMethod() {\n        System.out.println(\"This method is deprecated.\");\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p><code>@SuppressWarnings</code>: </p> <ul> <li>Suppresses compiler warnings.</li> <li>Benefit: Allows developers to suppress specific warnings, keeping the code clean without removing potentially useful constructs.</li> <li> <p>Example:</p> <pre><code>class Example {\n    @SuppressWarnings(\"unchecked\")\n    public void uncheckedMethod() {\n        // Suppresses unchecked warnings\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p><code>@FunctionalInterface</code>: </p> <ul> <li>Marks an interface as a functional interface (with a single abstract method).</li> <li>Benefit: Ensures that the interface has exactly one abstract method. If additional methods are added, the compiler will throw an error. Some IDEs also provide real-time feedback before compilation.</li> <li> <p>Example:</p> <pre><code>@FunctionalInterface\ninterface Greeting {\n    void sayHello(String name); // Single abstract method\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Greeting greeting = (name) -&gt; System.out.println(\"Hello, \" + name + \"!\");\n        greeting.sayHello(\"John\"); // Outputs: Hello, John!\n    }\n}\n</code></pre> </li> </ul> </li> </ul> <ul> <li>You can create custom annotations using <code>@interface</code>.</li> <li>Example:</li> </ul> <pre><code>import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface MyAnnotation {\n    String value();\n}\n\nclass Example {\n    @MyAnnotation(value = \"Custom Annotation Example\")\n    public void annotatedMethod() {\n        System.out.println(\"This method is annotated.\");\n    }\n}\n</code></pre> <ul> <li>Annotations with <code>RUNTIME</code> retention can be processed using reflection.</li> </ul> <pre><code>import java.lang.reflect.Method;\n\npublic class AnnotationProcessor {\n    public static void main(String[] args) throws Exception {\n        Method method = Example.class.getMethod(\"annotatedMethod\");\n        if (method.isAnnotationPresent(MyAnnotation.class)) {\n            MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);\n            System.out.println(\"Annotation value: \" + annotation.value());\n        }\n    }\n}\n</code></pre>"},{"location":"collections/","title":"Collections","text":""},{"location":"collections/#introduction-to-collections","title":"Introduction to Collections","text":"What is the Java Collections Framework? <ul> <li>The Java Collections Framework (JCF) is a set of classes and interfaces that implement commonly reusable collection data structures.</li> <li>It provides a unified architecture for storing, retrieving, and manipulating data.</li> <li>Key benefits:<ul> <li>Reduces programming effort by providing ready-to-use data structures.</li> <li>Improves performance with efficient algorithms.</li> <li>Increases code reusability and maintainability.</li> </ul> </li> <li>Key Interfaces:<ul> <li>Collection: Root interface for most collections.</li> <li>List: Ordered, allows duplicates (e.g., <code>ArrayList</code>, <code>LinkedList</code>).</li> <li>Set: No duplicates (e.g., <code>HashSet</code>, <code>TreeSet</code>).</li> <li>Queue: Holds elements for processing (e.g., <code>PriorityQueue</code>).</li> <li>Map: Key-value pairs (e.g., <code>HashMap</code>, <code>TreeMap</code>).</li> </ul> </li> </ul>"},{"location":"collections/#list-interface","title":"List Interface","text":"List Interface <ul> <li>Ordered collection allowing duplicates.</li> <li>Implementations:<ul> <li><code>ArrayList</code>: Resizable array.</li> <li><code>LinkedList</code>: Doubly-linked list.</li> <li><code>Vector</code>: Synchronized resizable array (legacy).</li> </ul> </li> </ul> Example: Using <code>ArrayList</code> <pre><code>import java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(\"Apple\");\n        list.add(\"Banana\");\n        list.add(\"Cherry\");\n\n        System.out.println(\"List: \" + list); // Outputs: [Apple, Banana, Cherry]\n\n        list.remove(\"Banana\");\n        System.out.println(\"After removal: \" + list); // Outputs: [Apple, Cherry]\n\n        System.out.println(\"Element at index 1: \" + list.get(1)); // Outputs: Cherry\n    }\n}\n</code></pre>"},{"location":"collections/#set-interface","title":"Set Interface","text":"Set Interface <ul> <li>No duplicate elements.</li> <li>Implementations:<ul> <li><code>HashSet</code>: Unordered.</li> <li><code>TreeSet</code>: Ordered.</li> <li><code>LinkedHashSet</code>: Maintains insertion order.</li> </ul> </li> </ul> Example: Using <code>HashSet</code> <pre><code>import java.util.HashSet;\n\npublic class Main {\n    public static void main(String[] args) {\n        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();\n        set.add(\"Apple\");\n        set.add(\"Banana\");\n        set.add(\"Apple\");\n\n        System.out.println(\"Set: \" + set); // Outputs: [Apple, Banana]\n    }\n}\n</code></pre>"},{"location":"collections/#map-interface","title":"Map Interface","text":"Map Interface <ul> <li>Key-value pairs.</li> <li>Implementations:<ul> <li><code>HashMap</code>: Unordered.</li> <li><code>TreeMap</code>: Ordered.</li> <li><code>LinkedHashMap</code>: Maintains insertion order.</li> </ul> </li> </ul> Example: Using <code>HashMap</code> <pre><code>import java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\n        map.put(\"Apple\", 1);\n        map.put(\"Banana\", 2);\n        map.put(\"Cherry\", 3);\n\n        System.out.println(\"Map: \" + map); // Outputs: {Apple=1, Banana=2, Cherry=3}\n\n        map.remove(\"Banana\");\n        System.out.println(\"After removal: \" + map); // Outputs: {Apple=1, Cherry=3}\n\n        System.out.println(\"Value for 'Apple': \" + map.get(\"Apple\")); // Outputs: 1\n    }\n}\n</code></pre>"},{"location":"collections/#queue-interface","title":"Queue Interface","text":"Queue Interface <ul> <li>Holds elements for processing.</li> <li>Implementations:<ul> <li><code>PriorityQueue</code>: Priority-based.</li> <li><code>LinkedList</code>: Can act as a queue.</li> </ul> </li> </ul> Example: Using <code>PriorityQueue</code> <pre><code>import java.util.PriorityQueue;\n\npublic class Main {\n    public static void main(String[] args) {\n        PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();\n        queue.add(10);\n        queue.add(5);\n        queue.add(20);\n\n        System.out.println(\"Queue: \" + queue); // Outputs: [5, 10, 20]\n\n        System.out.println(\"Polled element: \" + queue.poll()); // Outputs: 5\n        System.out.println(\"Queue after poll: \" + queue); // Outputs: [10, 20]\n    }\n}\n</code></pre>"},{"location":"collections/#iterator","title":"Iterator","text":"Iterator <ul> <li>Traverses collection elements.</li> <li>Methods:<ul> <li><code>hasNext()</code>: Checks for more elements.</li> <li><code>next()</code>: Retrieves the next element.</li> <li><code>remove()</code>: Removes the last returned element.</li> </ul> </li> </ul> Example: Using <code>Iterator</code> <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(\"Apple\");\n        list.add(\"Banana\");\n        list.add(\"Cherry\");\n\n        Iterator&lt;String&gt; iterator = list.iterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n    }\n}\n</code></pre>"},{"location":"collections/#comparable-and-comparator","title":"Comparable and Comparator","text":"Comparable and Comparator <ul> <li>Used for sorting collections.</li> </ul> Using <code>Comparable</code>Using <code>Comparator</code> <ul> <li>The <code>Comparable</code> interface is used to define the natural ordering of objects.</li> <li>It requires implementing the <code>compareTo()</code> method.</li> </ul> <pre><code>import java.util.ArrayList;\nimport java.util.Collections;\n\nclass Student implements Comparable&lt;Student&gt; {\n    String name;\n    int age;\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public int compareTo(Student other) {\n        return this.age - other.age; // Sort by age\n    }\n\n    @Override\n    public String toString() {\n        return name + \" (\" + age + \")\";\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;();\n        students.add(new Student(\"Alice\", 22));\n        students.add(new Student(\"Bob\", 20));\n        students.add(new Student(\"Charlie\", 25));\n\n        Collections.sort(students);\n        System.out.println(students); // Outputs: [Bob (20), Alice (22), Charlie (25)]\n    }\n}\n</code></pre> <ul> <li>The <code>Comparator</code> interface is used to define custom sorting logic.</li> <li>It requires implementing the <code>compare()</code> method.</li> </ul> <pre><code>import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\nclass Student {\n    String name;\n    int age;\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return name + \" (\" + age + \")\";\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;();\n        students.add(new Student(\"Alice\", 22));\n        students.add(new Student(\"Bob\", 20));\n        students.add(new Student(\"Charlie\", 25));\n\n        Collections.sort(students, new Comparator&lt;Student&gt;() {\n            @Override\n            public int compare(Student s1, Student s2) {\n                return s1.name.compareTo(s2.name);\n            }\n        });\n\n        System.out.println(students); // Outputs: [Alice (22), Bob (20), Charlie (25)]\n    }\n}\n</code></pre>"},{"location":"exceptions/","title":"Exception Handling","text":""},{"location":"exceptions/#overview","title":"Overview","text":"Overview <p>Exception handling in Java is a mechanism to handle runtime errors, ensuring the normal flow of the application. It uses <code>try</code>, <code>catch</code>, <code>finally</code>, <code>throw</code>, and <code>throws</code> keywords.</p> Basic Example <pre><code>try {\n    int result = 10 / 0; // This will throw ArithmeticException\n} catch (ArithmeticException e) {\n    System.out.println(\"Cannot divide by zero: \" + e.getMessage());\n} finally {\n    System.out.println(\"Execution completed.\");\n}\n</code></pre> Checked vs Unchecked Exceptions <ul> <li>Checked Exceptions: Must be declared in the method signature using <code>throws</code> or handled with <code>try-catch</code>.<ul> <li>Example: <code>IOException</code>, <code>SQLException</code></li> </ul> </li> <li>Unchecked Exceptions: Do not need to be declared or handled.<ul> <li>Example: <code>ArithmeticException</code>, <code>NullPointerException</code></li> </ul> </li> </ul> Custom Exceptions <p>You can create your own exceptions by extending the <code>Exception</code> class.</p> Example <pre><code>class CustomException extends Exception {\n    public CustomException(String message) {\n        super(message);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            throw new CustomException(\"This is a custom exception\");\n        } catch (CustomException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"Exception Hierarchy <p>The following diagram illustrates the hierarchy of exceptions in Java:</p> <pre><code>flowchart TD\n    Object --&gt; Throwable\n    Throwable --&gt; Error\n    Throwable --&gt; Exception\n    Error --&gt; ThreadDeath\n    Error --&gt; IOError\n    Error --&gt; OutOfMemoryError\n    Error --&gt; VirtualMachineError\n    Exception --&gt; RuntimeException\n    Exception --&gt; IOException\n    Exception --&gt; SQLException\n    RuntimeException --&gt; ArithmeticException\n    RuntimeException --&gt; NullPointerException\n    RuntimeException --&gt; IndexOutOfBoundsException</code></pre>"},{"location":"exceptions/#throws-keyword","title":"<code>throws</code> Keyword","text":"<code>throws</code> Keyword <ul> <li>The <code>throws</code> keyword in Java is used in a method declaration to specify the exceptions that the method can throw.</li> <li>It informs the caller of the method about the exceptions that need to be handled or declared further.</li> </ul> SyntaxExampleKey Points <pre><code>returnType methodName(parameters) throws ExceptionType1, ExceptionType2 {\n    // Method body\n}\n</code></pre> <pre><code>import java.io.IOException;\n\npublic class Example {\n    public void readFile() throws IOException {\n        throw new IOException(\"File not found\");\n    }\n\n    public static void main(String[] args) {\n        Example example = new Example();\n        try {\n            example.readFile();\n        } catch (IOException e) {\n            System.out.println(\"Caught exception: \" + e.getMessage());\n        }\n    }\n}\n</code></pre> <ul> <li>The <code>throws</code> keyword is used to declare checked exceptions.</li> <li>It does not handle the exception; it only propagates it to the caller.</li> <li>Multiple exceptions can be declared, separated by commas.</li> <li>Unchecked exceptions (subclasses of <code>RuntimeException</code>) do not need to be declared with <code>throws</code>.</li> </ul>"},{"location":"exceptions/#try-with-resources","title":"Try with Resources","text":"Try with Resources <ul> <li>The \"try-with-resources\" statement in Java is used to automatically close resources (like files, sockets, or database connections) that implement the <code>AutoCloseable</code> interface.</li> <li>Introduced in Java 7, it simplifies resource management and reduces boilerplate code.</li> </ul> SyntaxExampleKey Points <pre><code>try (ResourceType resource = new ResourceType()) {\n    // Use the resource\n} catch (ExceptionType e) {\n    // Handle exception\n}\n</code></pre> <pre><code>import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Example {\n    public static void main(String[] args) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"example.txt\"))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error reading file: \" + e.getMessage());\n        }\n    }\n}\n</code></pre> <ul> <li>Resources declared in the <code>try</code> block are automatically closed at the end of the block.</li> <li>Multiple resources can be declared, separated by semicolons (<code>;</code>).</li> <li>The resources must implement the <code>AutoCloseable</code> interface (or its subinterface, <code>Closeable</code>).</li> <li>Reduces the need for explicit <code>finally</code> blocks to close resources.</li> </ul>"},{"location":"jdbc/","title":"JDBC (Java Database Connectivity)","text":""},{"location":"jdbc/#overview","title":"Overview","text":"<p>JDBC is an API in Java that allows interaction with databases. It provides methods to query and update data in a database.</p> Key Features <ul> <li>Database Independence: JDBC allows Java applications to interact with any database that has a JDBC driver.</li> <li>Support for Multiple Databases: It supports various databases like MySQL, PostgreSQL, Oracle, etc.</li> <li>Connection Pooling: Improves performance by reusing connections.</li> </ul>"},{"location":"jdbc/#key-components","title":"Key Components","text":"Components <ul> <li>JDBC Driver: Implements the JDBC API for a specific database.</li> <li>DriverManager: Manages database drivers and establishes connections.</li> <li>Connection: Represents a connection to a database.</li> <li>Statement: Executes SQL queries.</li> <li>PreparedStatement: Precompiled SQL statement for parameterized queries.</li> <li>CallableStatement: Executes stored procedures.</li> <li>ResultSet: Represents query results, allowing iteration over data.</li> <li>SQLException: Handles database access errors.</li> <li>Batch Processing: Executes multiple SQL statements in a single batch.</li> <li>Transaction Management: Groups multiple operations into a single unit of work.</li> <li>RowSet: Flexible wrapper around ResultSet.</li> <li>DataSource: Alternative to DriverManager, often used in enterprise applications for connection pooling and distributed transactions.</li> </ul>"},{"location":"jdbc/#steps-to-connect-to-a-database","title":"Steps to Connect to a Database","text":"Connection Steps <ol> <li>Load the JDBC Driver:</li> </ol> <p><pre><code>Class.forName(\"com.mysql.cj.jdbc.Driver\");\n</code></pre> 2. Establish a Connection:</p> <p><pre><code>Connection connection = DriverManager.getConnection(\n     \"jdbc:mysql://localhost:3306/dbname\", \"username\", \"password\");\n</code></pre> 3. Create a Statement:</p> <p><pre><code>Statement statement = connection.createStatement();\n</code></pre> 4. Execute a Query:</p> <p><pre><code>ResultSet resultSet = statement.executeQuery(\"SELECT * FROM table_name\");\n</code></pre> 5. Process the Results:</p> <p><pre><code>while (resultSet.next()) {\n    System.out.println(resultSet.getString(\"column_name\"));\n}\n</code></pre> 6. Close the Connection:</p> <pre><code>// Close the ResultSet\nresultSet.close();\n// Close the Statement\nstatement.close();\n// Close the Connection\nconnection.close();\n</code></pre>"},{"location":"jdbc/#best-practices","title":"Best Practices","text":"Best Practices <ul> <li>Use <code>try-with-resources</code> to automatically close resources.</li> <li>Use <code>PreparedStatement</code> to prevent SQL injection.</li> <li>Handle exceptions properly to avoid crashes.</li> <li>Use connection pooling for better performance.</li> <li>Avoid <code>Statement</code> for dynamic queries; prefer <code>PreparedStatement</code>.</li> <li>Always close <code>Connection</code>, <code>Statement</code>, and <code>ResultSet</code> objects.</li> </ul>"},{"location":"jdbc/#additional-concepts","title":"Additional Concepts","text":""},{"location":"jdbc/#transaction-management","title":"Transaction Management","text":"<ul> <li>Start a Transaction: Use <code>connection.setAutoCommit(false);</code>.</li> <li>Commit Changes: Use <code>connection.commit();</code>.</li> <li>Rollback Changes: Use <code>connection.rollback();</code>.</li> </ul>"},{"location":"jdbc/#error-handling","title":"Error Handling","text":"<ul> <li>Catch <code>SQLException</code> for database-related errors.</li> <li>Use <code>getMessage()</code>, <code>getSQLState()</code>, and <code>getErrorCode()</code> for debugging.</li> </ul>"},{"location":"jdbc/#connection-pooling","title":"Connection Pooling","text":"<ul> <li>Use libraries like HikariCP or Apache DBCP for efficient connection management.</li> </ul>"},{"location":"jdbc/#batch-processing","title":"Batch Processing","text":"<ul> <li>Use <code>addBatch()</code> and <code>executeBatch()</code> for executing multiple queries efficiently.</li> </ul>"},{"location":"jdbc/#metadata-handling","title":"Metadata Handling","text":"<ul> <li>Use <code>DatabaseMetaData</code> and <code>ResultSetMetaData</code> to retrieve database and result set information.</li> </ul>"},{"location":"jdbc/#example-code","title":"Example Code","text":"JDBC Example <pre><code>import java.sql.*;\n\npublic class JDBCDemo {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/dbname\";\n        String user = \"username\";\n        String password = \"password\";\n\n        try {\n            // Load the driver\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n\n            // Establish a connection\n            Connection connection = DriverManager.getConnection(url, user, password);\n\n            // Create a statement\n            Statement statement = connection.createStatement();\n\n            // Execute a query\n            ResultSet resultSet = statement.executeQuery(\"SELECT * FROM table_name\");\n\n            // Process the results\n            while (resultSet.next()) {\n                System.out.println(resultSet.getString(\"column_name\"));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (resultSet != null) resultSet.close();\n                if (statement != null) statement.close();\n                if (connection != null) connection.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"lambda/","title":"Lambda Expressions","text":"Lambda Expressions <ul> <li>Lambda expressions provide a concise way to represent anonymous functions, introduced in Java 8.</li> <li>Commonly used with functional interfaces (interfaces with a single abstract method).</li> <li>Benefits:<ul> <li>Reduces boilerplate code.</li> <li>Enhances readability and maintainability.</li> <li>Simplifies operations on collections and functional interfaces.</li> </ul> </li> </ul> Basic SyntaxUsing with CollectionsMethod ReferencesFunctional Interfaces <ul> <li>Syntax: <code>(parameters) -&gt; expression</code> or <code>(parameters) -&gt; { statements }</code></li> <li>Example:</li> </ul> <pre><code>interface Greeting {\n    void sayHello(String name);\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Greeting greeting = (name) -&gt; System.out.println(\"Hello, \" + name + \"!\");\n        greeting.sayHello(\"John\"); // Outputs: Hello, John!\n    }\n}\n</code></pre> <ul> <li>Simplifies operations like filtering, mapping, and iterating.</li> </ul> <pre><code>import java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List&lt;String&gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\n        names.stream()\n             .filter(name -&gt; name.startsWith(\"A\"))\n             .forEach(System.out::println); // Outputs: Alice\n    }\n}\n</code></pre> <ul> <li>Method references provide a shorthand notation for calling methods using <code>ClassName::methodName</code>.</li> </ul> <pre><code>import java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List&lt;String&gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\n        names.forEach(System.out::println); // Outputs: Alice Bob Charlie\n    }\n}\n</code></pre> <ul> <li>Compatible with functional interfaces like <code>Predicate</code>, <code>Function</code>, <code>Consumer</code>, and <code>Supplier</code>.</li> </ul> <pre><code>import java.util.function.Predicate;\n\npublic class Main {\n    public static void main(String[] args) {\n        Predicate&lt;Integer&gt; isEven = n -&gt; n % 2 == 0;\n        System.out.println(isEven.test(4)); // Outputs: true\n    }\n}\n</code></pre>"},{"location":"streams/","title":"Streams","text":""},{"location":"streams/#stream-api","title":"Stream API","text":"Stream API Overview <ul> <li>Introduced in Java 8, the Stream API provides a functional programming approach to process collections of data declaratively.</li> <li>Key Features:<ul> <li>Lazy Evaluation: Operations are executed only when a terminal operation is invoked.</li> <li>Parallel Processing: Streams can process data concurrently.</li> <li>Immutability: Streams do not modify the source data.</li> <li>Non-Reusability: Streams cannot be reused after a terminal operation.</li> </ul> </li> </ul> Example: Non-ReusabilityCommon Operations <pre><code>List&lt;String&gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\nvar stream = names.stream();\nstream.forEach(System.out::println); // Terminal operation\nstream.forEach(System.out::println); // Throws IllegalStateException\n</code></pre> <ul> <li>Intermediate: <code>filter()</code>, <code>map()</code>, <code>sorted()</code>. They return a new stream and are lazy.</li> <li>Terminal: <code>forEach()</code>, <code>collect()</code>, <code>reduce()</code>. Produce a result or side effect and consume the stream.</li> </ul> <pre><code>List&lt;String&gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\nList&lt;String&gt; filtered = names.stream()\n                             .filter(name -&gt; name.startsWith(\"A\"))\n                             .collect(Collectors.toList());\nSystem.out.println(filtered); // Outputs: [Alice]\n</code></pre>"},{"location":"streams/#common-stream-functions","title":"Common Stream Functions","text":"Stream Functions <ul> <li> <ul> <li> <p><code>filter(Predicate)</code>: Filters elements.</p> <pre><code>List&lt;Integer&gt; even = numbers.stream()\n                            .filter(n -&gt; n % 2 == 0)\n                            .collect(Collectors.toList());\n</code></pre> </li> </ul> <p>Intermediate Operations:</p> <ul> <li> <p><code>map(Function)</code>: Transforms elements.</p> <pre><code>List&lt;Integer&gt; lengths = names.stream()\n                             .map(String::length)\n                             .collect(Collectors.toList());\n</code></pre> </li> <li> <p><code>sorted()</code>: Sorts elements.</p> <pre><code>List&lt;Integer&gt; sorted = numbers.stream()\n                              .sorted()\n                              .collect(Collectors.toList());\n</code></pre> </li> <li> <p><code>distinct()</code>: Removes duplicates.</p> <pre><code>List&lt;Integer&gt; unique = numbers.stream()\n                              .distinct()\n                              .collect(Collectors.toList());\n</code></pre> </li> </ul> </li> <li> <p>Terminal Operations:</p> <ul> <li> <p><code>forEach(Consumer)</code>: Performs an action for each element.</p> <pre><code>names.stream().forEach(System.out::println);\n</code></pre> </li> <li> <p><code>collect(Collector)</code>: Collects elements into a collection.</p> <pre><code>Set&lt;String&gt; nameSet = names.stream()\n                           .collect(Collectors.toSet());\n</code></pre> </li> <li> <p><code>reduce(BinaryOperator)</code>: Reduces elements to a single value.</p> <pre><code>int sum = numbers.stream().reduce(0, Integer::sum);\n</code></pre> </li> <li> <p><code>count()</code>: Counts elements.</p> <pre><code>long count = names.stream().count();\n</code></pre> </li> </ul> </li> </ul>"},{"location":"streams/#parallel-streams","title":"Parallel Streams","text":"Parallel Streams <ul> <li>Parallel streams divide data into chunks for concurrent processing.</li> <li>Use <code>parallelStream()</code> or <code>stream().parallel()</code>.</li> </ul> ExampleCaution <pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nnumbers.parallelStream()\n       .forEach(n -&gt; System.out.println(Thread.currentThread().getName() + \" - \" + n));\n</code></pre> <ul> <li>Avoid <code>sorted()</code> with parallel streams due to unpredictable results.</li> </ul> <pre><code>List&lt;Integer&gt; numbers = Arrays.asList(5, 3, 1, 4, 2);\n\n// Sequential stream with sorted\nList&lt;Integer&gt; sortedNumbers = numbers.stream()\n                                     .sorted()\n                                     .collect(Collectors.toList());\nSystem.out.println(sortedNumbers); // Outputs: [1, 2, 3, 4, 5]\n\n// Avoid using sorted with parallel streams\nList&lt;Integer&gt; parallelSortedNumbers = numbers.parallelStream()\n                                             .sorted()\n                                             .collect(Collectors.toList());\nSystem.out.println(parallelSortedNumbers); // May produce unpredictable results\n</code></pre>"},{"location":"streams/#foreach-method","title":"<code>forEach</code> Method","text":"<code>forEach</code> Method <ul> <li>A terminal operation used for side effects like printing or logging.</li> <li>Avoid modifying the data source within <code>forEach</code>.</li> </ul> Example <pre><code>List&lt;String&gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\n// Using Lambda Expression\nnames.stream().forEach(name -&gt; System.out.println(\"Name: \" + name));\n\n// Using Method Reference\nnames.stream().forEach(System.out::println);\n</code></pre>"},{"location":"strings/","title":"String","text":""},{"location":"strings/#string-creation-and-memory","title":"String Creation and Memory","text":"String Initialization <p>In Java, <code>String</code> is a final class, meaning it cannot be extended. Strings are objects and can be created in two ways:</p> <ul> <li>String Literal (Recommended): Stored in the String Constant Pool, reuses references for identical strings.</li> </ul> <p><pre><code>String str = \"Hello\";  // Reuses reference\n</code></pre> - String Object: Stored in Heap Memory, creates a new object even if identical string exists.</p> <pre><code>String str = new String(\"Hello\");\n</code></pre> String Immutability and Garbage Collection <p>Strings are immutable. Modifying a string creates a new object, leaving the original eligible for garbage collection if unreferenced.</p> <pre><code>String str = \"Hello\";\nstr = \"World\"; // \"Hello\" becomes eligible for garbage collection\nSystem.out.println(str); // Outputs: World\n</code></pre>"},{"location":"strings/#mutable-strings","title":"Mutable Strings","text":"Mutable Strings <ul> <li>StringBuilder: Faster, not thread-safe.</li> <li>StringBuffer: Thread-safe, slower due to synchronization.</li> </ul> <p>Use <code>StringBuilder</code> for performance in single-threaded scenarios and <code>StringBuffer</code> for thread-safe operations.</p> <pre><code>StringBuilder sb = new StringBuilder(\"Hello\");\nsb.append(\" World\"); // Modifies the original object\nSystem.out.println(sb); // Outputs: Hello World\n</code></pre> <p>Use these classes in loops or for frequent string modifications to avoid creating multiple immutable objects.</p> <pre><code>StringBuilder sb = new StringBuilder();\nfor (int i = 0; i &lt; 100000; i++) {\n    sb.append(i); // Efficient thanks to mutable nature. If strings were used, it would create 100,000 objects.\n}\nSystem.out.println(sb.toString());\n</code></pre>"},{"location":"strings/#string-joiner","title":"String Joiner","text":"Joining Strings <ul> <li>Joins strings with a delimiter, prefix, and suffix.</li> </ul> <pre><code>import java.util.StringJoiner;\n\nStringJoiner joiner = new StringJoiner(\", \", \"[\", \"]\");\njoiner.add(\"Apple\").add(\"Banana\").add(\"Orange\");\nSystem.out.println(joiner); // Outputs: [Apple, Banana, Orange]\n</code></pre>"},{"location":"threads/","title":"Threads","text":""},{"location":"threads/#introduction-to-threads","title":"Introduction to Threads","text":"What are Threads? <ul> <li>Threads are lightweight sub-processes enabling concurrent task execution.</li> <li>Java supports multithreading via the <code>Thread</code> class and <code>Runnable</code> interface.</li> </ul> Key Points <ul> <li>Threads share memory but have individual stacks.</li> <li>States: <code>NEW</code>, <code>RUNNABLE</code>, <code>BLOCKED</code>, <code>WAITING</code>, <code>TIMED_WAITING</code>, <code>TERMINATED</code>.</li> </ul>"},{"location":"threads/#creating-threads","title":"Creating Threads","text":"Ways to Create Threads <ul> <li>Extend <code>Thread</code> class or implement <code>Runnable</code> interface.</li> </ul> Extending <code>Thread</code> ClassImplementing <code>Runnable</code> Interface <pre><code>class MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Thread is running...\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyThread thread = new MyThread();\n        thread.start(); // Starts the thread\n    }\n}\n</code></pre> <pre><code>class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Thread is running...\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Thread thread = new Thread(new MyRunnable());\n        thread.start(); // Starts the thread\n    }\n}\n</code></pre>"},{"location":"threads/#thread-lifecycle","title":"Thread Lifecycle","text":"Thread Lifecycle <ul> <li>A thread in Java goes through the following states:<ol> <li>NEW: The thread is created but not yet started.</li> <li>RUNNABLE: The thread is ready to run and waiting for CPU time.</li> <li>RUNNING: The thread is executing.</li> <li>BLOCKED/WAITING/TIMED_WAITING: The thread is waiting for a resource or signal.</li> <li>TERMINATED: The thread has completed execution.</li> </ol> </li> </ul> Lifecycle Example <pre><code>class MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Thread is running...\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyThread thread = new MyThread();\n        System.out.println(\"State: \" + thread.getState()); // NEW\n        thread.start();\n        System.out.println(\"State: \" + thread.getState()); // RUNNABLE\n\n        try {\n            thread.join(); // Wait for the thread to finish\n        } catch (InterruptedException e) {\n            System.out.println(\"Main thread interrupted: \" + e.getMessage());\n        }\n        System.out.println(\"State: \" + thread.getState()); // TERMINATED\n    }\n}\n</code></pre>"},{"location":"threads/#thread-methods","title":"Thread Methods","text":"Common Thread Methods <ul> <li><code>start()</code>: Starts the thread.</li> <li><code>run()</code>: Contains the code to be executed by the thread.</li> <li><code>sleep(milliseconds)</code>: Pauses the thread for a specified time.</li> <li><code>join()</code>: Waits for a thread to finish execution.</li> <li><code>isAlive()</code>: Checks if the thread is still running.</li> <li><code>setPriority(priority)</code>: Sets the thread's priority.</li> <li><code>getPriority()</code>: Gets the thread's priority.</li> </ul> Example: <code>sleep</code> and <code>join</code> <pre><code>class MyThread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 1; i &lt;= 5; i++) {\n            System.out.println(\"Thread: \" + i);\n            try {\n                Thread.sleep(500); // Pause for 500ms\n            } catch (InterruptedException e) {\n                System.out.println(\"Interrupted: \" + e.getMessage());\n            }\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyThread thread = new MyThread();\n        thread.start();\n        try {\n            thread.join(); // Wait for the thread to finish\n        } catch (InterruptedException e) {\n            System.out.println(\"Main interrupted: \" + e.getMessage());\n        }\n        System.out.println(\"Main finished.\");\n    }\n}\n</code></pre>"},{"location":"threads/#synchronization","title":"Synchronization","text":"Thread Synchronization <ul> <li>Synchronization is used to control access to shared resources in multithreaded environments.</li> <li>It prevents thread interference and ensures data consistency.</li> </ul> Using <code>synchronized</code> Keyword <pre><code>class Counter {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Counter counter = new Counter();\n\n        Thread t1 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) counter.increment();\n        });\n\n        Thread t2 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) counter.increment();\n        });\n\n        t1.start();\n        t2.start();\n\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            System.out.println(\"Interrupted: \" + e.getMessage());\n        }\n\n        System.out.println(\"Final count: \" + counter.getCount()); // Outputs: 2000\n    }\n}\n</code></pre>"},{"location":"threads/#deadlock","title":"Deadlock","text":"Deadlock <ul> <li>Occurs when threads wait indefinitely for each other to release resources.</li> </ul> ExampleAvoiding Deadlock <pre><code>class Resource {\n    void methodA(Resource other) {\n        synchronized (this) {\n            System.out.println(Thread.currentThread().getName() + \" locked this\");\n            synchronized (other) {\n                System.out.println(Thread.currentThread().getName() + \" locked other\");\n            }\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Resource r1 = new Resource();\n        Resource r2 = new Resource();\n\n        Thread t1 = new Thread(() -&gt; r1.methodA(r2), \"Thread-1\");\n        Thread t2 = new Thread(() -&gt; r2.methodA(r1), \"Thread-2\");\n\n        t1.start();\n        t2.start();\n    }\n}\n</code></pre> <ul> <li>Use consistent resource acquisition order.</li> <li>Use <code>tryLock</code> from <code>java.util.concurrent.locks</code>.</li> </ul>"},{"location":"threads/#thread-pool","title":"Thread Pool","text":"Thread Pool <ul> <li>A thread pool is a collection of pre-created threads that can be reused for executing tasks.</li> <li>It improves performance by reducing the overhead of thread creation and destruction.</li> </ul> Using <code>ExecutorService</code> <pre><code>import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Main {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(3);\n\n        for (int i = 1; i &lt;= 5; i++) {\n            int taskId = i;\n            executor.execute(() -&gt; {\n                System.out.println(\"Task \" + taskId + \" is running on \" + Thread.currentThread().getName());\n            });\n        }\n\n        executor.shutdown(); // Shut down the executor\n    }\n}\n</code></pre>"},{"location":"threads/#concurrency-utilities","title":"Concurrency Utilities","text":"Concurrency Utilities <ul> <li>Java provides utilities in the <code>java.util.concurrent</code> package for advanced multithreading and concurrency control.</li> </ul> Common Utilities <ul> <li><code>ReentrantLock</code>: A lock with more control than <code>synchronized</code>.</li> <li><code>CountDownLatch</code>: A synchronization aid that allows threads to wait for a set of operations to complete.</li> <li><code>CyclicBarrier</code>: A synchronization aid that allows threads to wait for each other at a common barrier point.</li> <li><code>Semaphore</code>: A counting semaphore for controlling access to a resource.</li> <li><code>ExecutorService</code>: A framework for managing thread pools.</li> </ul> Example: <code>CountDownLatch</code> <pre><code>import java.util.concurrent.CountDownLatch;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(3);\n\n        Runnable task = () -&gt; {\n            System.out.println(Thread.currentThread().getName() + \" completed.\");\n            latch.countDown(); // Decrement the latch count\n        };\n\n        Thread t1 = new Thread(task, \"Thread-1\");\n        Thread t2 = new Thread(task, \"Thread-2\");\n        Thread t3 = new Thread(task, \"Thread-3\");\n\n        t1.start();\n        t2.start();\n        t3.start();\n\n        latch.await(); // Wait for all threads to complete\n        System.out.println(\"All threads completed.\");\n    }\n}\n</code></pre>"},{"location":"threads/#race-condition","title":"Race Condition","text":"What is a Race Condition? <ul> <li>A race condition occurs when two or more threads access shared data and try to modify it simultaneously.</li> <li>The final outcome depends on the order in which the threads execute, leading to unpredictable behavior.</li> </ul> ExamplePrevention <pre><code>class Counter {\n    private int count = 0;\n\n    public void increment() {\n        count++;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Counter counter = new Counter();\n\n        Thread t1 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) counter.increment();\n        });\n\n        Thread t2 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) counter.increment();\n        });\n\n        t1.start();\n        t2.start();\n\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            System.out.println(\"Interrupted: \" + e.getMessage());\n        }\n\n        System.out.println(\"Final count: \" + counter.getCount()); // May not be 2000 due to race condition\n    }\n}\n</code></pre> <ul> <li>Use <code>synchronized</code> or thread-safe classes like <code>AtomicInteger</code>.</li> </ul> Example: <code>AtomicInteger</code> <pre><code>import java.util.concurrent.atomic.AtomicInteger;\n\nclass Counter {\n    private AtomicInteger count = new AtomicInteger(0);\n\n    public void increment() {\n        count.incrementAndGet();\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Counter counter = new Counter();\n\n        Thread t1 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) counter.increment();\n        });\n\n        Thread t2 = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 1000; i++) counter.increment();\n        });\n\n        t1.start();\n        t2.start();\n\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            System.out.println(\"Interrupted: \" + e.getMessage());\n        }\n\n        System.out.println(\"Final count: \" + counter.getCount()); // Outputs: 2000\n    }\n}\n</code></pre>"},{"location":"basics/1_data_types/","title":"Data Types","text":""},{"location":"basics/1_data_types/#primitive-data-types","title":"Primitive Data Types","text":"Type Size Description <code>byte</code> 1 byte 8-bit signed integer <code>short</code> 2 bytes 16-bit signed integer <code>int</code> 4 bytes 32-bit signed integer <code>long</code> 8 bytes 64-bit signed integer <code>float</code> 4 bytes Single-precision 32-bit IEEE 754 floating point <code>double</code> 8 bytes Double-precision 64-bit IEEE 754 floating point <code>char</code> 2 bytes Single 16-bit Unicode character <code>boolean</code> 1 bit Stores <code>true</code> or <code>false</code> values Default Types <p>In Java, the default integer type is <code>int</code>, and the default floating-point type is <code>double</code>. To use <code>long</code> or <code>float</code>, you must specify them explicitly. For example:</p> <pre><code>long x = 10L;\nfloat y = 10.5f;\n</code></pre> Default Values <p>Unlike C/C++, Java initializes variables to default values if not explicitly assigned. Below is a table summarizing the default values for various data types:</p> Type Default Value <code>integer</code> 0 <code>floating-point</code> 0.0 <code>char</code> '\\u0000' <code>boolean</code> false Reference Types null Character Data Type <p>The <code>char</code> data type is used to store a single 16-bit Unicode character. It can be defined using single quotes, Unicode escape sequences, or decimal values.</p> <pre><code>char singleQuoteChar = 'A';     // Represents 'A'\nchar unicodeChar = '\\u0042';    // Represents 'B'\nchar decimalChar = 66;          // Represents 'B'\n</code></pre> Boolean Data Type <p>Only <code>true</code> or <code>false</code> values are allowed. <code>[0, 1]</code> are not allowed.</p> <pre><code>boolean isTrue = true;          // Represents true\nboolean isFalse = false;        // Represents false\n</code></pre>"},{"location":"basics/1_data_types/#special-features","title":"Special Features","text":"Numeric Literals <p>Numeric literals can be represented in decimal, hexadecimal, octal, or binary formats.</p> <pre><code>int decimal = 100;              // Decimal\nint hex = 0x64;                 // Hexadecimal\nint hex = 0x64;                 // Hexadecimal\nint octal = 0144;               // Octal \nint binary = 0b1100100;         // Binary\n</code></pre> <p>Use underscores (<code>_</code>) in numeric literals for better readability:</p> <pre><code>int x = 1_00_000;               // 100000\n</code></pre>"},{"location":"basics/1_data_types/#type-casting","title":"Type Casting","text":"Type Casting Type Promotion <p>In expressions, Java automatically promotes smaller data types to larger ones to avoid data loss. For example:</p> <pre><code>byte a = 10;\nbyte b = 30;\nint c = a * b;                  // a and b are promoted to int\nSystem.out.println(c);          // Output: 300\n</code></pre>"},{"location":"basics/1_data_types/#implicit-casting","title":"Implicit Casting","text":"<p>When assigning a smaller data type to a larger data type (no data loss occurs also called widening conversion):</p> <pre><code>int x = 10;\nlong y = x;                     // Implicit casting\n</code></pre>"},{"location":"basics/1_data_types/#explicit-casting","title":"Explicit Casting","text":"<p>When assigning a larger data type to a smaller data type (may result in data loss):</p> <pre><code>long x = 10;\nint y = (int) x;                // Explicit casting\nbyte z = (byte) y;              // Further explicit casting\n</code></pre>"},{"location":"basics/2_conditionals/","title":"Conditionals","text":""},{"location":"basics/2_conditionals/#vs-and-vs","title":"<code>&amp;</code> vs <code>&amp;&amp;</code> and <code>|</code> vs <code>||</code>","text":"Key Differences <ul> <li><code>&amp;</code> and <code>|</code>: Bitwise operators (for numbers) or Logical operators (for booleans, no short-circuit).</li> <li><code>&amp;&amp;</code> and <code>||</code>: Logical operators (only for booleans, with short-circuiting).</li> </ul> Common Bug <p>Using <code>&amp;</code> or <code>|</code> instead of <code>&amp;&amp;</code> or <code>||</code> can cause hidden bugs:</p> Incorrect Usage with <code>&amp;</code>Correct usage with <code>&amp;&amp;</code> <p><pre><code>int number = 0;\nif (number != 0 &amp; (10 / number) &gt; 1) { // Crashes\n    System.out.println(\"Safe division!\");\n}\n</code></pre> \u274c This crashes with a <code>Division by zero</code> error because <code>&amp;</code> evaluates both sides.</p> <p><pre><code>int number = 0;\nif (number != 0 &amp;&amp; (10 / number) &gt; 1) {\n    System.out.println(\"Safe division!\");\n}\n</code></pre> \u2705 No error, as <code>&amp;&amp;</code> skips the second condition if the first is false.</p> Rule of Thumb <ul> <li>Use <code>&amp;&amp;</code> and <code>||</code> for logical conditions (better for safety and performance).</li> <li>Use <code>&amp;</code> and <code>|</code> only when both sides must be evaluated (rare cases).</li> </ul>"},{"location":"basics/2_conditionals/#ternary-operator","title":"Ternary Operator (<code>? :</code>)","text":"What is the Ternary Operator? <p>The ternary operator is a shorthand for <code>if-else</code> statements. It has the syntax:</p> <p><pre><code>condition ? value_if_true : value_if_false;\n</code></pre> Example:</p> <pre><code>int a = 10, b = 20;\nint max = (a &gt; b) ? a : b; // Assigns the larger value to max\nSystem.out.println(\"Max: \" + max); // Output: Max: 20\n</code></pre> When to Use <ul> <li>Use the ternary operator for simple conditional assignments.</li> <li>Avoid using it for complex logic as it can reduce code readability.</li> </ul>"},{"location":"basics/2_conditionals/#enhanced-switch-expression-java-12","title":"Enhanced <code>switch</code> Expression (Java 12+)","text":"What is the Enhanced <code>switch</code>? <p>The enhanced <code>switch</code> expression simplifies the syntax by removing the need for <code>break</code> statements and allows returning values directly. Example:</p> Traditional <code>switch</code>:Enhanced <code>switch</code>: <pre><code>int day = 2;\nString dayName;\nswitch (day) {\n    case 1:\n        dayName = \"Monday\";\n        break;\n    case 2:\n        dayName = \"Tuesday\";\n        break;\n    default:\n        dayName = \"Unknown\";\n}\nSystem.out.println(dayName); // Output: Tuesday\n</code></pre> <p><pre><code>int day = 2;\nString dayName = switch (day) {\n    case 1 -&gt; \"Monday\";\n    case 2 -&gt; \"Tuesday\";\n    default -&gt; \"Unknown\";\n};\nSystem.out.println(dayName); // Output: Tuesday\n</code></pre> - The <code>-&gt;</code> operator is used to define the case actions, eliminating the need for <code>break</code> statements.</p> When to Use <ul> <li>Use the enhanced <code>switch</code> for cleaner and more concise code.</li> <li>It is especially useful when returning values directly from a <code>switch</code>.</li> </ul>"},{"location":"basics/3_arrays/","title":"Arrays","text":""},{"location":"basics/3_arrays/#quick-reference","title":"Quick Reference","text":"<p>Array Declaration and Initialization</p> <pre><code>int[] arr = new int[5];        // Fixed-size declaration\nint[] arr = {1, 2, 3};         // Initialization\nint[][] matrix = new int[3][]; // Jagged array\n</code></pre> When to Use Arrays <ul> <li>Use arrays when you need a fixed-size collection of elements of the same type.</li> <li>Ideal for scenarios where you need fast access to elements using an index.</li> <li>Arrays are memory-efficient and provide better performance for fixed-size data.</li> </ul> Drawbacks of Arrays <ul> <li>Fixed Size: Size cannot be changed after declaration.</li> <li>Homogeneous Data: Only stores elements of the same type.</li> <li>Limited Methods: No built-in methods for resizing, searching, or sorting.</li> </ul>"},{"location":"basics/3_arrays/#jagged-arrays","title":"Jagged Arrays","text":"What are Jagged Arrays? <p>Arrays of arrays where sub-arrays can have different sizes, useful for non-rectangular data like triangles or sparse matrices.</p> <pre><code>int[][] jaggedArray = new int[3][];\njaggedArray[0] = new int[]{1, 2};\njaggedArray[1] = new int[]{3, 4, 5};\njaggedArray[2] = new int[]{6};\n\nfor (int[] row : jaggedArray) {\n    for (int num : row) {\n        System.out.print(num + \" \");\n    }\n    System.out.println();\n}\n// Output:\n// 1 2\n// 3 4 5\n// 6\n</code></pre>"},{"location":"basics/3_arrays/#arrays-of-objects","title":"Arrays of Objects","text":"Arrays of Objects <ul> <li>Arrays of objects store references to the objects, not the objects themselves.</li> <li>Each object in the array must be manually created and initialized.</li> <li>If an object is not initialized, its reference will be <code>null</code>. In this case, trying to access its properties or methods will result in a <code>NullPointerException</code>.</li> </ul> ExampleExceptions <pre><code>class Person {\n    String name;\n    Person(String name) {\n        this.name = name;\n    }\n}\n\nPerson[] people = new Person[3];\npeople[0] = new Person(\"Alice\");\npeople[1] = new Person(\"Bob\");\npeople[2] = new Person(\"Charlie\");\n\nfor (Person person : people) {\n    System.out.println(person.name);\n}\n// Output:\n// Alice\n// Bob\n// Charlie\n</code></pre> <pre><code>Person[] people = new Person[3];\n// people[0] is null, accessing it will throw NullPointerException\nSystem.out.println(people[0].name); // Throws NullPointerException\n</code></pre>"},{"location":"oop/1_class_object_inheritance/","title":"Class, Object, and Inheritance","text":""},{"location":"oop/1_class_object_inheritance/#class-and-object","title":"Class and Object","text":"Class and Object ClassObjectKey DifferencesAnonymous Object <ul> <li>A class is a blueprint or template for creating objects.</li> <li>It defines fields (attributes/properties) and methods (behaviors/functions).</li> <li>Can include constructors, static blocks, and nested classes.</li> <li>Loaded once by the class loader and stored in the Method Area.</li> <li>No memory for fields is allocated until an object is created.</li> <li>Classes help organize code and promote reusability.</li> </ul> <pre><code>class Car {\n    String color;\n    void drive() {\n        System.out.println(\"Driving...\");\n    }\n}\n</code></pre> <ul> <li>An object is an instance of a class.</li> <li>Has its own state (values of fields) and behavior (methods).</li> <li>Created using the <code>new</code> keyword; memory is allocated in the heap.</li> <li>Multiple objects can be created from the same class, each with independent state.</li> <li>Objects are garbage collected when no longer referenced.</li> </ul> <pre><code>Car myCar = new Car(); // Object creation\nmyCar.color = \"Red\";\nmyCar.drive();\n</code></pre> Class Object Blueprint/template Instance of a class No memory allocated Memory allocated in heap Defines structure Has actual data/state Loaded once Can create many objects Stored in Method Area Stored in Heap <ul> <li>An object created without a reference variable.</li> <li>Useful for one-time method calls or quick operations.</li> <li>Destroyed after the statement; no reference is kept.</li> </ul> <pre><code>new Car().drive(); // Anonymous object\n</code></pre> <ul> <li>Common in event handling and callbacks.</li> <li>Saves memory if the object is not needed after the method call.</li> </ul> <ul> <li>Class: Blueprint, defines structure, no memory until instantiated.</li> <li>Object: Instance, has state/behavior, memory allocated in heap.</li> <li>Anonymous Object: No reference, used for one-time actions.</li> </ul> <p>Tip: Use classes to model real-world entities and objects to represent specific instances in your programs.</p>"},{"location":"oop/1_class_object_inheritance/#inheritance","title":"Inheritance","text":"Inheritance <ul> <li>Inheritance allows a class (child class) to acquire properties and methods of another class (parent class).</li> <li>It promotes code reuse and establishes a parent-child relationship.</li> <li>Java supports single inheritance, where a class can extend only one parent class. However, this can be multi-leveled (a class can inherit from another class, which in turn inherits from another class, and so on).</li> <li>Java does not support multiple inheritance with classes to avoid ambiguity (commonly referred to as the \"diamond problem\").</li> <li>Multiple inheritance is supported through interfaces, allowing a class to implement multiple interfaces.</li> <li>The <code>extends</code> keyword is used to inherit from a class, and the <code>implements</code> keyword is used to implement interfaces.</li> <li>For inheritance to work, the compiled <code>.class</code> files of the parent class must be available in the classpath.</li> </ul> Multiple Inheritance through InterfacesMethod Resolution in Multiple Interfaces <pre><code>interface InterfaceA {\n    void methodA();\n}\n\ninterface InterfaceB {\n    void methodB();\n}\n\n// A class implementing both interfaces\nclass Implementation implements InterfaceA, InterfaceB {\n    @Override\n    public void methodA() {\n        System.out.println(\"Method A from InterfaceA\");\n    }\n\n    @Override\n    public void methodB() {\n        System.out.println(\"Method B from InterfaceB\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Implementation obj = new Implementation();\n        obj.methodA(); // Calls methodA from InterfaceA\n        obj.methodB(); // Calls methodB from InterfaceB\n    }\n}\n</code></pre> <ul> <li>If two interfaces have methods with the same signature, the implementing class must override the method to resolve ambiguity.</li> </ul> <pre><code>interface InterfaceA {\n    default void display() {\n        System.out.println(\"Display from InterfaceA\");\n    }\n}\n\ninterface InterfaceB {\n    default void display() {\n        System.out.println(\"Display from InterfaceB\");\n    }\n}\n\n// A class implementing both interfaces\nclass Implementation implements InterfaceA, InterfaceB {\n    @Override\n    public void display() {\n        // Resolving ambiguity by explicitly calling methods from both interfaces\n        InterfaceA.super.display();\n        InterfaceB.super.display();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Implementation obj = new Implementation();\n        obj.display(); // Calls display methods from both interfaces\n    }\n}\n</code></pre>"},{"location":"oop/1_class_object_inheritance/#this-and-super-keywords","title":"<code>this</code> and <code>super</code> Keywords","text":"this and super <ul> <li><code>this</code> refers to the current object, used to resolve naming conflicts or call another constructor in the same class.</li> <li><code>super</code> refers to the parent class, used to access parent class members or call its constructor.</li> <li><code>this()</code> and <code>super()</code> must be the first statement in a constructor.</li> <li>If <code>super()</code> is not explicitly called, the compiler adds it by default.</li> </ul> Using <code>this</code> and <code>super</code> in ConstructorsUsing <code>this</code> in Methods <pre><code>class A {\n    public A() {\n        System.out.println(\"in A\");\n    }\n    public A(int n) {\n        System.out.println(\"in A int\");\n    }\n}\n\nclass B extends A {\n    public B() {\n        super(); // Calls parent class constructor\n        System.out.println(\"in B\");\n    }\n    public B(int n) {\n        this();  // Calls another constructor in the same class\n        System.out.println(\"in B int\");\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        B obj = new B(5); // Output: in A, in B, in B int\n        // Additional test to demonstrate the use of constructors\n        B obj2 = new B(); // Output: in A, in B\n    }\n}\n</code></pre> <pre><code>class Example {\n    int x;\n\n    Example(int x) {\n        this.x = x; // Resolves naming conflict\n    }\n\n    void display() {\n        System.out.println(\"Value of x: \" + this.x);\n    }\n\n    void setX(int x) {\n        this.x = x; // Refers to the instance variable\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Example obj = new Example(10);\n        obj.display(); // Output: Value of x: 10\n        obj.setX(20);\n        obj.display(); // Output: Value of x: 20\n    }\n}\n</code></pre>"},{"location":"oop/1_class_object_inheritance/#inner-class","title":"Inner Class","text":"Inner Class <ul> <li>An Inner Class is a class defined within another class.</li> <li>Inner classes can access the members (including private members) of the outer class.</li> <li>They are used to logically group classes that are only used in one place or to increase encapsulation.</li> <li>Types of inner classes:<ul> <li>Non-static Inner Class: Associated with an instance of the outer class.</li> <li>Static Nested Class: Does not require an instance of the outer class.</li> <li>Local Inner Class: Defined inside a method or block.</li> <li>Anonymous Inner Class: A class without a name, used for one-time use.</li> </ul> </li> </ul> Non-static Inner ClassStatic Nested ClassLocal Inner ClassAnonymous Inner ClassWhen to Use Each Type <ul> <li>Tied to an instance of the outer class.</li> <li>Can access all members of the outer class, including private ones.</li> <li>Use when the inner class logically depends on an instance of the outer class.</li> </ul> <pre><code>class Outer {\n    private String message = \"Hello from Outer class!\";\n\n    class Inner {\n        void display() {\n            System.out.println(message); // Accessing outer class's private member\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Outer outer = new Outer(); // Create an object of the outer class\n        Outer.Inner inner = outer.new Inner(); // Create an object of the inner class\n        inner.display(); // Outputs: Hello from Outer class!\n    }\n}\n</code></pre> <ul> <li>Not tied to an instance of the outer class.</li> <li>Can only access static members of the outer class.</li> <li>Use when the nested class does not require access to instance members of the outer class.</li> </ul> <pre><code>class Outer {\n    static String staticMessage = \"Hello from Outer class!\";\n\n    static class Nested {\n        void display() {\n            System.out.println(staticMessage); // Accessing static member of the outer class\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Outer.Nested nested = new Outer.Nested(); // Create an instance of the static nested class\n        nested.display(); // Outputs: Hello from Outer class!\n    }\n}\n</code></pre> <ul> <li>Defined inside a method or block.</li> <li>Can access local variables of the enclosing method if they are declared <code>final</code> or effectively final.</li> <li>Use for encapsulating logic that is specific to a single method.</li> </ul> <pre><code>class Outer {\n    void display() {\n        final String localMessage = \"Hello from Local Inner Class!\";\n\n        class LocalInner {\n            void print() {\n                System.out.println(localMessage); // Accessing local variable\n            }\n        }\n\n        LocalInner localInner = new LocalInner();\n        localInner.print(); // Outputs: Hello from Local Inner Class!\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Outer outer = new Outer();\n        outer.display();\n    }\n}\n</code></pre> <ul> <li>A class without a name, used for one-time use.</li> <li>Can provide an implementation of an interface, extend a class, or instantiate an abstract class.</li> <li>Use for quick, one-off implementations.</li> </ul> <pre><code>abstract class Shape {\n    abstract void draw();\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Instantiating an abstract class using an anonymous inner class\n        Shape shape = new Shape() {\n            @Override\n            void draw() {\n                System.out.println(\"Drawing a shape using an anonymous inner class!\");\n            }\n        };\n\n        shape.draw(); // Outputs: Drawing a shape using an anonymous inner class!\n    }\n}\n</code></pre> <ul> <li>Non-static Inner Class: When the inner class needs access to instance members of the outer class.</li> <li>Static Nested Class: When the inner class does not need access to instance members of the outer class.</li> <li>Local Inner Class: When the inner class is specific to a method and encapsulates method-specific logic.</li> <li>Anonymous Inner Class: When a one-time implementation of an interface, abstract class, or superclass is needed.</li> </ul>"},{"location":"oop/2_modifiers/","title":"Modifiers","text":""},{"location":"oop/2_modifiers/#access-modifiers","title":"Access Modifiers","text":"Access Modifiers <ul> <li>Access modifiers define the visibility and accessibility of classes, methods, and variables.</li> <li>The table below summarizes the accessibility of different access modifiers:</li> </ul> private default protected public Same Class \u2705 \u2705 \u2705 \u2705 Same Package \u274c \u2705 \u2705 \u2705 Same Package Subclass \u274c \u274c \u2705 \u2705 Different Package Subclass \u274c \u274c \u2705 \u2705 Different Package Non-SubClass \u274c \u274c \u274c \u2705"},{"location":"oop/2_modifiers/#non-access-modifiers","title":"Non-Access Modifiers","text":"Non-Access Modifiers <ul> <li>Non-access modifiers provide additional functionality to classes, methods, and variables.</li> <li>Common non-access modifiers include <code>static</code>, <code>final</code>, <code>abstract</code>, <code>synchronized</code>, and <code>volatile</code>.</li> </ul>"},{"location":"oop/2_modifiers/#static-keyword","title":"Static Keyword","text":"Static Keyword <ul> <li>The <code>static</code> keyword makes a variable, method, or block belong to the class rather than instances. It is shared across all instances and can be accessed without creating an object.</li> </ul> Static VariablesStatic MethodsStatic BlocksStatic Nested ClassesOrder of Execution <ul> <li>Shared by all instances of a class.</li> <li>Initialized once when the class is loaded.</li> <li>Accessed using the class name.</li> </ul> <pre><code>class Example {\n    static int staticVar = 0;\n    void increment() {\n        staticVar++; // \u2705 Accessing static variable within instance method\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Example obj1 = new Example();\n        obj1.increment();\n        System.out.println(Example.staticVar); // Outputs: 1\n    }\n}\n</code></pre> <ul> <li>Called without creating an object.</li> <li>Can access static variables directly but require an object reference to access instance variables.</li> </ul> <pre><code>class Example {\n    static int staticVar = 0;\n    int instanceVar = 0;\n\n    static void staticMethod() {\n        System.out.println(\"Static var: \" + staticVar);     // \u2705 Accessing static variable in static method\n        System.out.println(\"Instance var: \" + instanceVar); // \u274c Accessing instance variable in static method will cause compilation error\n    }\n\n    static void staticMethod(Example obj) {\n        System.out.println(\"Instance var: \" + obj.instanceVar); // \u2705 Accessing instance variable in static method using object reference\n    }\n}\n</code></pre> <ul> <li>Used to initialize static variables or perform setup tasks.</li> <li>Executed once when the class is loaded, before any object creation or <code>main()</code> execution.</li> </ul> <pre><code>class Example {\n    static int staticVar;\n    static {\n        staticVar = 10;\n        System.out.println(\"Static block executed.\");\n    }\n}\n</code></pre> <ul> <li>A static class inside another class.</li> <li>Does not require an instance of the outer class.</li> <li>Can access static members of the outer class.</li> </ul> <pre><code>class OuterClass {\n    static int staticVar = 10;\n\n    static class NestedClass {\n        void display() {\n            System.out.println(\"Static var: \" + staticVar);\n        }\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        OuterClass.NestedClass nested = new OuterClass.NestedClass();\n        nested.display(); // Outputs: Static var: 10\n    }\n}\n</code></pre> <ul> <li>Static variables and blocks are executed in the order they appear in the class.</li> <li>They run only once when the class is loaded.</li> </ul> <pre><code>class Example {\n    static int staticVar = initializeStaticVar();\n    static {\n        System.out.println(\"Static block executed.\");\n    }\n\n    static int initializeStaticVar() {\n        System.out.println(\"Static variable initialized.\");\n        return 42;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Static var: \" + Example.staticVar);\n    }\n}\n// Output:\n// Static variable initialized.\n// Static block executed.\n// Static var: 42\n</code></pre>"},{"location":"oop/2_modifiers/#final-keyword","title":"Final Keyword","text":"Final Keyword <ul> <li>The <code>final</code> keyword restricts modification of variables, methods, and classes.</li> </ul> Final VariableFinal MethodFinal Class <ul> <li>A <code>final</code> variable is a constant and cannot be reassigned after initialization.</li> <li>Must be initialized during declaration, in a constructor, or in a block.</li> </ul> <pre><code>class Example {\n    final int constant;\n\n    Example(int value) {\n        this.constant = value; // Initialization in constructor\n    }\n\n    // Uncommenting the following statement will cause a compilation error\n    // void modifyConstant() { constant = 10; }\n}\n</code></pre> <ul> <li>A <code>final</code> method cannot be overridden by subclasses but can be inherited and overloaded.</li> </ul> <pre><code>class Parent {\n    final void display() {\n        System.out.println(\"This is a final method.\");\n    }\n}\n\nclass Child extends Parent {\n    // Uncommenting the following will cause a compilation error\n    // void display() {  } // Cannot override final method\n\n    void display(String message) { // Overloading is allowed\n        System.out.println(message);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Child child = new Child();\n        child.display(\"Overloaded method.\"); // Outputs: Overloaded method.\n    }\n}\n</code></pre> <ul> <li>A <code>final</code> class cannot be extended but can be instantiated and used.</li> </ul> <pre><code>final class FinalClass {\n    void display() {\n        System.out.println(\"This is a final class.\");\n    }\n}\n\n// Uncommenting the following will cause a compilation error\n// class SubClass extends FinalClass {}\n\npublic class Main {\n    public static void main(String[] args) {\n        FinalClass obj = new FinalClass();\n        obj.display(); // Outputs: This is a final class.\n    }\n}\n</code></pre>"},{"location":"oop/3_polymorphism/","title":"Polymorphism","text":"Polymorphism <ul> <li>Polymorphism allows methods to perform different tasks based on the object or context.</li> <li>It is categorized into:</li> </ul> Compile-Time Polymorphism (Method Overloading)Run-Time Polymorphism (Method Overriding) <ul> <li>Resolved at compile-time.</li> <li>Methods have the same name but differ in the number or type of arguments.</li> </ul> <pre><code>class Calculator {\n    int add(int a, int b) {\n        return a + b;\n    }\n    double add(double a, double b) {\n        return a + b;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator calc = new Calculator();\n        System.out.println(calc.add(2, 3));       // Outputs: 5\n        System.out.println(calc.add(2.5, 3.5));   // Outputs: 6.0\n    }\n}\n</code></pre> <ul> <li>Resolved at runtime.</li> <li>Methods have the same name and signature but are overridden in subclasses.</li> <li>Dynamic method dispatch determines the method to call based on the object type.</li> </ul> <pre><code>class Animal {\n    void eat() {\n        System.out.println(\"Animal is eating\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    void eat() {\n        System.out.println(\"Dog is eating\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Animal a = new Dog(); // Polymorphic reference\n        a.eat();              // Outputs: Dog is eating\n    }\n}\n</code></pre>"},{"location":"oop/3_polymorphism/#casting-in-polymorphism","title":"Casting in Polymorphism","text":"Casting <ul> <li>Casting is used to convert objects between parent and child classes, often in the context of polymorphism.</li> </ul> UpcastingDowncasting <ul> <li>Casting from a subclass to a superclass.</li> <li>Done implicitly or explicitly.</li> <li>Allows treating a child class object as a parent class object.</li> </ul> <pre><code>class Animal {\n    void sound() {\n        System.out.println(\"Animal makes a sound\");\n    }\n}\n\nclass Dog extends Animal {\n    void sound() {\n        System.out.println(\"Dog barks\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Animal a = new Dog(); // Implicit upcasting\n        a.sound();            // Outputs: Dog barks\n    }\n}\n</code></pre> <ul> <li>Casting from a superclass to a subclass.</li> <li>Must be done explicitly.</li> <li>Allows access to methods and fields specific to the subclass.</li> <li>Requires type checking with <code>instanceof</code> to avoid <code>ClassCastException</code>.</li> </ul> <pre><code>class Animal {\n    void sound() {\n        System.out.println(\"Animal makes a sound\");\n    }\n}\n\nclass Dog extends Animal {\n    void fetch() {\n        System.out.println(\"Dog fetches the ball\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Animal a = new Dog(); // Upcasting\n        if (a instanceof Dog) {\n            Dog d = (Dog) a;  // Explicit downcasting\n            d.fetch();        // Outputs: Dog fetches the ball\n        }\n    }\n}\n</code></pre>"},{"location":"oop/4_abstraction/","title":"Abstraction","text":""},{"location":"oop/4_abstraction/#abstract-class","title":"Abstract Class","text":"Abstract Class <ul> <li>An abstract class is a blueprint for other classes and cannot be instantiated directly.</li> <li>Declared with the <code>abstract</code> keyword, it can include:<ul> <li>Abstract methods: Methods without implementation that must be overridden by subclasses.</li> <li>Concrete methods: Methods with implementation that can be inherited by subclasses.</li> </ul> </li> <li>Abstract classes allow code reuse and enforce a structure for subclasses.</li> </ul> Key FeaturesExample: Abstract ClassAbstract Class vs Interface <ul> <li>Cannot be instantiated directly.</li> <li>Can have both abstract and concrete methods.</li> <li>Can have constructors, which are called during subclass instantiation.</li> <li>Abstract methods cannot be private, static, or final.</li> </ul> <pre><code>abstract class Shape {\n    protected String color;\n\n    public Shape(String color) {\n        this.color = color;\n    }\n\n    abstract double calculateArea();\n\n    public void displayColor() {\n        System.out.println(\"Color: \" + color);\n    }\n}\n\nclass Circle extends Shape {\n    private double radius;\n\n    public Circle(String color, double radius) {\n        super(color);\n        this.radius = radius;\n    }\n\n    @Override\n    double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class AbstractDemo {\n    public static void main(String[] args) {\n        // Shape shape = new Shape(\"Red\"); // \u274c Cannot instantiate abstract class\n        Circle circle = new Circle(\"Blue\", 5.0);\n        circle.displayColor();             // Outputs: Color: Blue\n        System.out.println(\"Area: \" + circle.calculateArea()); // Outputs: Area: 78.54\n    }\n}\n</code></pre> Feature Abstract Class Interface Instantiation Cannot be instantiated Cannot be instantiated Inheritance Single inheritance only Multiple inheritance possible Fields Can have instance variables Only constants (public static final) Methods Abstract and concrete methods Abstract (pre-Java 8), default/static (Java 8+) Constructor Can have constructors Cannot have constructors Purpose \"is-a\" relationship (shared code) \"can-do\" relationship (API contract) Usage For related classes with shared implementation For unrelated classes needing common behavior"},{"location":"oop/4_abstraction/#interface","title":"Interface","text":"Interface <ul> <li>An Interface defines a contract for behavior and is implemented by classes.</li> <li>Key characteristics:<ul> <li>All methods are <code>public</code> and <code>abstract</code> by default (pre-Java 8).</li> <li>All variables are <code>public</code>, <code>static</code>, and <code>final</code> by default.</li> <li>Supports multiple inheritance.</li> <li>Can have default and static methods (since Java 8).</li> <li>Functional interfaces (with a single abstract method) are used in lambda expressions.</li> </ul> </li> </ul> ExampleDefault and Static Methods (Java 8+)Functional Interface and Lambda ExpressionsMarker InterfaceExtending Interfaces <pre><code>interface Animal {\n    void eat();     // implicitly public and abstract\n    void sleep();\n}\n\nclass Dog implements Animal {\n    @Override\n    public void eat() {\n        System.out.println(\"Dog is eating\");\n    }\n\n    @Override\n    public void sleep() {\n        System.out.println(\"Dog is sleeping\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal dog = new Dog();\n        dog.eat();   // Outputs: Dog is eating\n        dog.sleep(); // Outputs: Dog is sleeping\n    }\n}\n</code></pre> <pre><code>interface Vehicle {\n    void start();\n\n    default void stop() { // Default method\n        System.out.println(\"Vehicle is stopping\");\n    }\n\n    static void service() { // Static method\n        System.out.println(\"Vehicle is being serviced\");\n    }\n}\n\nclass Car implements Vehicle {\n    @Override\n    public void start() {\n        System.out.println(\"Car is starting\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle car = new Car();\n        car.start();       // Outputs: Car is starting\n        car.stop();        // Outputs: Vehicle is stopping\n        Vehicle.service(); // Outputs: Vehicle is being serviced\n    }\n}\n</code></pre> <ul> <li>Functional interfaces are essential for enabling functional programming in Java.</li> <li>They simplify the use of lambda expressions and method references, making code more concise and readable.</li> </ul> <pre><code>@FunctionalInterface\ninterface Greeting {\n    void sayHello(String name);\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Greeting greeting = (name) -&gt; System.out.println(\"Hello, \" + name + \"!\");\n        greeting.sayHello(\"John\"); // Outputs: Hello, John!\n    }\n}\n</code></pre> Method ReferencesConstructor References <ul> <li>Method references provide a shorthand for calling methods using the <code>::</code> operator.</li> <li>Types of method references:<ol> <li>Static Method Reference: <code>ClassName::staticMethod</code></li> <li>Instance Method Reference: <code>instance::instanceMethod</code></li> <li>Instance Method of an Arbitrary Object: <code>ClassName::instanceMethod</code></li> </ol> </li> </ul> <pre><code>import java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List&lt;String&gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\n        // Static method reference\n        names.forEach(System.out::println); // Outputs: Alice Bob Charlie\n\n        // Instance method reference\n        names.stream()\n             .map(String::toUpperCase)\n             .forEach(System.out::println); // Outputs: ALICE BOB CHARLIE\n    }\n}\n</code></pre> <ul> <li>Constructor references are used to create objects using the <code>::</code> operator.</li> <li>Syntax: <code>ClassName::new</code></li> </ul> <pre><code>import java.util.function.Supplier;\n\nclass Example {\n    String message;\n\n    public Example() {\n        this.message = \"Default Constructor\";\n    }\n\n    public Example(String message) {\n        this.message = message;\n    }\n\n    @Override\n    public String toString() {\n        return message;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Constructor reference for default constructor\n        Supplier&lt;Example&gt; defaultConstructor = Example::new;\n        Example example1 = defaultConstructor.get();\n        System.out.println(example1); // Outputs: Default Constructor\n\n        // Constructor reference for parameterized constructor\n        java.util.function.Function&lt;String, Example&gt; paramConstructor = Example::new;\n        Example example2 = paramConstructor.apply(\"Parameterized Constructor\");\n        System.out.println(example2); // Outputs: Parameterized Constructor\n    }\n}\n</code></pre> <ul> <li>Marker Interface: An interface with no methods, used to mark a class for specific behavior (e.g., <code>Serializable</code>).</li> </ul> <pre><code>// Marker Interface Example\ninterface Marker {}\n\nclass Example implements Marker {\n    // Class marked with Marker interface\n}\n</code></pre> <pre><code>interface A {\n    void methodA();\n}\n\ninterface B extends A {\n    void methodB();\n}\n\nclass Implementation implements B {\n    @Override\n    public void methodA() {\n        System.out.println(\"Method A from Interface A\");\n    }\n\n    @Override\n    public void methodB() {\n        System.out.println(\"Method B from Interface B\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        B obj = new Implementation();\n        obj.methodA(); // Outputs: Method A from Interface A\n        obj.methodB(); // Outputs: Method B from Interface B\n    }\n}\n</code></pre>"},{"location":"oop/4_abstraction/#when-to-use","title":"When to Use","text":"When to Use Abstract Classes <ul> <li>Use abstract classes when:<ul> <li>You need to share code among closely related classes.</li> <li>You want to provide a common base class with default behavior.</li> <li>You need constructors or non-final instance variables.</li> </ul> </li> </ul> When to Use Interfaces <ul> <li>Use interfaces when:<ul> <li>You need to define a contract for unrelated classes.</li> <li>You want to achieve multiple inheritance.</li> <li>You need to take advantage of default or static methods (Java 8+).</li> <li>You are designing functional interfaces for lambda expressions.</li> </ul> </li> </ul>"},{"location":"oop/5_object_class/","title":"Object Class","text":"<code>Object</code> Class <ul> <li>The <code>Object</code> class is the root class of all classes in Java.</li> <li>Every class in Java implicitly extends the <code>Object</code> class unless explicitly specified otherwise.</li> <li>Commonly used methods include <code>toString()</code> and <code>equals()</code>.</li> </ul> toString() Methodequals() Method <ul> <li>The <code>toString()</code> method returns a string representation of the object.</li> <li>By default, it returns the class name followed by the <code>@</code> symbol and the hash code of the object.</li> <li>It is often overridden to provide a meaningful string representation of the object.</li> </ul> <pre><code>class Example {\n    int id;\n    String name;\n\n    Example(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Example{id=\" + id + \", name='\" + name + \"'}\";\n    }\n}\n</code></pre> <ul> <li>The <code>equals()</code> method is used to compare two objects for equality.</li> <li>By default, it checks if two references point to the same object (reference equality).</li> <li>It is often overridden to compare the content of objects (value equality).</li> </ul> <pre><code>class Example {\n    int id;\n    String name;\n\n    Example(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true; // Check if references are the same\n        if (obj == null || getClass() != obj.getClass()) return false; // Check class type\n        Example example = (Example) obj;\n        return id == example.id &amp;&amp; name.equals(example.name); // Compare fields\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Example obj1 = new Example(1, \"John\");\n        Example obj2 = new Example(1, \"John\");\n        Example obj3 = new Example(2, \"Doe\");\n\n        System.out.println(obj1.equals(obj2)); // Outputs: true\n        System.out.println(obj1.equals(obj3)); // Outputs: false\n    }\n}\n</code></pre>"},{"location":"oop/6_wrapper_class/","title":"Wrapper Class","text":"Wrapper Class <ul> <li>Wrapper classes in Java convert primitive types into objects and vice versa.</li> <li>Since J2SE 5.0, autoboxing and unboxing automate this conversion.</li> </ul> Boxing and UnboxingAutoboxing and AutounboxingInteger Cache <ul> <li>Boxing: Converts a primitive type into its corresponding wrapper class object.</li> <li>Unboxing: Converts a wrapper class object back into its corresponding primitive type.</li> </ul> <pre><code>public class Main {\n    public static void main(String[] args) {\n        int x = 10;\n        Integer y = Integer.valueOf(x); // Boxing\n        int z = y.intValue();          // Unboxing\n\n        System.out.println(\"Boxed: \" + y); // Outputs: Boxed: 10\n        System.out.println(\"Unboxed: \" + z); // Outputs: Unboxed: 10\n    }\n}\n</code></pre> <ul> <li>Autoboxing: Automatically converts a primitive type into its wrapper class object.</li> <li>Autounboxing: Automatically converts a wrapper class object back into its primitive type.</li> </ul> <pre><code>public class Main {\n    public static void main(String[] args) {\n        int x = 20;\n        Integer y = x; // Autoboxing\n        int z = y;     // Autounboxing\n\n        System.out.println(\"Autoboxed: \" + y); // Outputs: Autoboxed: 20\n        System.out.println(\"Autounboxed: \" + z); // Outputs: Autounboxed: 20\n    }\n}\n</code></pre> <ul> <li>Comparing two <code>Integer</code> objects using <code>==</code> depends on whether the values are within the Integer cache range (-128 to 127).</li> </ul> <p><pre><code>public class Main {\n    public static void main(String[] args) {\n        Integer i1 = 127;\n        Integer i2 = 127;\n        System.out.println(i1 == i2); // Outputs: true (within cache range)\n\n        Integer i3 = 128;\n        Integer i4 = 128;\n        System.out.println(i3 == i4); // Outputs: false (outside cache range)\n    }\n}\n</code></pre> - Explanation: Java caches <code>Integer</code> objects for values between -128 and 127. For values outside this range, new objects are created, so <code>==</code> compares references, not values.</p>"},{"location":"oop/7_enum/","title":"Enum","text":"Enum <ul> <li>An Enum is a special data type that represents a group of constants.</li> <li>Enums are used to define a fixed set of related constants, such as days of the week, directions, or states.</li> <li>Key characteristics:<ul> <li>Enums are implicitly <code>final</code> and <code>static</code>.</li> <li>Enum constants are <code>public</code>, <code>static</code>, and <code>final</code> by default.</li> <li>Enums can have fields, methods, and constructors.</li> <li>Enums can implement interfaces but cannot extend classes (as they implicitly extend <code>java.lang.Enum</code>).</li> </ul> </li> </ul> Basic ExampleWith Fields and MethodsWith Switch StatementImplementing an Interface <pre><code>enum Day {\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Day today = Day.MONDAY;\n        System.out.println(\"Today is: \" + today); // Outputs: Today is: MONDAY\n\n        for (Day day : Day.values()) {\n            System.out.println(day);\n        }\n    }\n}\n</code></pre> <ul> <li>Enums can have fields, methods, and constructors to associate additional data with each constant.</li> </ul> <pre><code>enum Planet {\n    EARTH(5.97e+24, 6.371e6);\n\n    private final double mass;   // in kilograms\n    private final double radius; // in meters\n\n    Planet(double mass, double radius) {\n        this.mass = mass;\n        this.radius = radius;\n    }\n\n    public double surfaceGravity() {\n        final double G = 6.67430e-11; // Gravitational constant\n        return G * mass / (radius * radius);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Earth's Gravity: \" + Planet.EARTH.surfaceGravity());\n    }\n}\n</code></pre> <ul> <li>Enums are often used with <code>switch</code> statements for better readability and control.</li> </ul> <pre><code>enum TrafficLight {\n    RED, YELLOW, GREEN\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        TrafficLight signal = TrafficLight.RED;\n\n        switch (signal) {\n            case RED -&gt; System.out.println(\"Stop!\");\n            case YELLOW -&gt; System.out.println(\"Get Ready!\");\n            case GREEN -&gt; System.out.println(\"Go!\");\n        }\n    }\n}\n</code></pre> <ul> <li>Enums can implement interfaces to define behavior for each constant.</li> </ul> <pre><code>interface Operation {\n    double apply(double x, double y);\n}\n\nenum Calculator implements Operation {\n    ADD {\n        @Override\n        public double apply(double x, double y) {\n            return x + y;\n        }\n    },\n    MULTIPLY {\n        @Override\n        public double apply(double x, double y) {\n            return x * y;\n        }\n    };\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Calculator.ADD.apply(10, 5)); // Outputs: 15.0\n    }\n}\n</code></pre>"},{"location":"oop/8_optional_class/","title":"Optional Class","text":"What is the <code>Optional</code> Class? <ul> <li>Introduced in Java 8, the <code>Optional</code> class helps handle null values gracefully, avoiding <code>NullPointerException</code>.</li> </ul> Key FeaturesWhen to Use <ul> <li>Avoid Null Checks: Reduces explicit null checks.</li> <li>Functional Style: Supports <code>map()</code>, <code>filter()</code>, and <code>ifPresent()</code>.</li> <li>Immutability: Values cannot be modified after creation.</li> </ul> <ul> <li>Use as a return type for methods that may return null.</li> <li>Avoid for fields, parameters, or collections to reduce overhead.</li> </ul> Creating an <code>Optional</code>Common MethodsExample <ul> <li> <p>Empty Optional: Represents no value.</p> <pre><code>Optional&lt;String&gt; empty = Optional.empty();\nSystem.out.println(empty.isPresent()); // false\n</code></pre> </li> <li> <p>With a Value: Wraps a non-null value.</p> <pre><code>Optional&lt;String&gt; optional = Optional.of(\"Hello\");\nSystem.out.println(optional.isPresent()); // true\n</code></pre> </li> <li> <p>With Nullable Value: Allows null values.</p> <pre><code>Optional&lt;String&gt; nullable = Optional.ofNullable(null);\nSystem.out.println(nullable.isPresent()); // false\n</code></pre> </li> </ul> <ul> <li> <p><code>isPresent()</code>: Checks if a value exists.</p> <pre><code>Optional&lt;String&gt; optional = Optional.of(\"Hello\");\nSystem.out.println(optional.isPresent()); // true\n</code></pre> </li> <li> <p><code>ifPresent(Consumer)</code>: Executes code if a value exists.</p> <pre><code>Optional&lt;String&gt; optional = Optional.of(\"Hello\");\noptional.ifPresent(value -&gt; System.out.println(\"Value: \" + value)); // Hello\n</code></pre> </li> <li> <p><code>orElse(T)</code>: Returns the value or a default.</p> <pre><code>Optional&lt;String&gt; optional = Optional.ofNullable(null);\nSystem.out.println(optional.orElse(\"Default\")); // Default\n</code></pre> </li> <li> <p><code>orElseGet(Supplier)</code>: Returns the value or invokes a supplier.</p> <pre><code>Optional&lt;String&gt; optional = Optional.ofNullable(null);\nSystem.out.println(optional.orElseGet(() -&gt; \"Generated Default\")); // Generated Default\n</code></pre> </li> <li> <p><code>orElseThrow(Supplier)</code>: Throws an exception if no value exists.</p> <pre><code>Optional&lt;String&gt; optional = Optional.ofNullable(null);\ntry {\n    System.out.println(optional.orElseThrow(() -&gt; new IllegalArgumentException(\"Value is missing\")));\n} catch (Exception e) {\n    System.out.println(e.getMessage()); // Value is missing\n}\n</code></pre> </li> <li> <p><code>map(Function)</code>: Transforms the value if present.</p> <pre><code>Optional&lt;String&gt; optional = Optional.of(\"Hello\");\nOptional&lt;Integer&gt; length = optional.map(String::length);\nSystem.out.println(length.orElse(0)); // 5\n</code></pre> </li> <li> <p><code>filter(Predicate)</code>: Filters the value based on a condition.</p> <pre><code>Optional&lt;String&gt; optional = Optional.of(\"Hello\");\noptional.filter(value -&gt; value.startsWith(\"H\"))\n        .ifPresent(System.out::println); // Hello\n</code></pre> </li> </ul> <pre><code>import java.util.Optional;\n\npublic class Main {\n    public static void main(String[] args) {\n        Optional&lt;String&gt; optional = Optional.ofNullable(getValue());\n\n        optional.ifPresent(value -&gt; System.out.println(\"Value: \" + value));\n\n        String result = optional.orElse(\"Default Value\");\n        System.out.println(\"Result: \" + result);\n\n        optional.map(String::toUpperCase)\n                .ifPresent(System.out::println);\n    }\n\n    private static String getValue() {\n        return null; // Simulates a method that may return null\n    }\n}\n</code></pre>"}]}